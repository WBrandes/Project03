package me.willyb.main;

import java.util.ArrayList;

import me.willyb.neighborhood.Address;

public class Router {
	
	public double x;
	public double y;
	public int direction;
	ArrayList<Command> currentRouteCommands;
	TurnMethod turningMethod;
	
	public double totalDistance = 0.0;
	public ArrayList<Double> totalDistanceRecord = new ArrayList<Double>();
	
	public Router(double x, double y, int direction, TurnMethod method) {
		
		this.x = x;
		this.y = y;
		this.direction = direction;
		this.turningMethod = method;
		currentRouteCommands = new ArrayList<Command>();
		
	}
	
	public ArrayList<Command> findRouteToAddress(Address a) {
		
		double xDif = x - a.x;
		double yDif = y - a.y;
		
		boolean xAligned = Math.abs(xDif) < 0.5;
		boolean yAligned = Math.abs(yDif) < 0.5;
		
		//Whether or not we should align the truck with the address in the x dimension first
		boolean xPriority = !xAligned && (((int) a.x) % 100 == 0);
		
		if(xAligned && yAligned) {
						
			return currentRouteCommands;
			
		} else {
			
			//Before we do any routing around, we want to make sure we're at an intersection, for simplicity of the algorithm
			//So if either of our coordinates is not a multiple of 100, we'll bring them to the hundred in front of them in that dimension, bringing us to an intersection
			if(((int) Math.round(x)) % 100 != 0 && direction % 2 == 1) {
								
				double newX = Math.ceil(x / 100.0) * 100.0;
				boolean above = true;
				
				if(direction == 3) {
					
					newX = Math.floor(x / 100.0) * 100.0;
					above = false;
					
				}
				
				//Updating total distance
				totalDistance += Math.abs(newX - x);
				totalDistanceRecord.add(totalDistance);
				
				currentRouteCommands.add(new Command(-1000, true, true, Function.START));
				currentRouteCommands.add(new Command(newX, true, above, Function.STOP));
				x = newX;
								
			} else if(((int) Math.round(y)) % 100 != 0 && direction % 2 == 0) {
								
				double newY = Math.ceil(y / 100.0) * 100.0;
				boolean above = true;
				
				if(direction == 0) {
					
					newY = Math.floor(y / 100.0) * 100.0;
					above = false;
					
				}
				
				//Updating total distance
				totalDistance += Math.abs(newY - y);
				totalDistanceRecord.add(totalDistance);
				
				currentRouteCommands.add(new Command(-1000, true, true, Function.START));
				currentRouteCommands.add(new Command(newY, false, above, Function.STOP));
				y = newY;
								
			}
			
			xDif = x - a.x;
			yDif = y - a.y;
			
			xAligned = Math.abs(xDif) < 0.5;
			yAligned = Math.abs(yDif) < 0.5;
			
			if(xAligned && yAligned) {
								
				return currentRouteCommands;
				
			}
			
			//If we should align with address' x coordinate
			if(xPriority || yAligned) {
				
				//Getting the direction we need to be facing to align with the address' x coordinate.
				int requiredDirection = 3;
				if(xDif < 0) {
					
					requiredDirection = 1;
					
				}
				
				//Turn to face the proper direction of our target, on the x axis
				if(direction != requiredDirection) {
				
					turningMethod.faceDirection(this, requiredDirection);
				
				}
				
				//Updating total distance
				totalDistance += Math.abs(a.x - x);
				totalDistanceRecord.add(totalDistance);
				
				//Stop when we reach a value at or greater than our goal, if we're heading east. If we're heading west, stop when we reach a value at or lower than our goal.
				boolean above = direction == 1;
				
				currentRouteCommands.add(new Command(-1000, true, true, Function.START));
				currentRouteCommands.add(new Command(a.x, true, above, Function.STOP));
				x = a.x;
								
			//If we should align with address' y coordinate
			} else {
				
				//Getting the direction we need to be facing to align with the address' u coordinate.
				int requiredDirection = 0;
				if(yDif < 0) {
					
					requiredDirection = 2;
					
				}
								
				//Turn to face the proper direction of our target, on the y axis
				if(direction != requiredDirection) {
				
					turningMethod.faceDirection(this, requiredDirection);
				
				}
				
				totalDistance += Math.abs(a.y - y);
				totalDistanceRecord.add(totalDistance);
				
				//Stop when we reach a value at or greater than our goal, if we're heading south. If we're heading north, stop when we reach a value at or lower than our goal.
				boolean above = direction == 2;
				
				currentRouteCommands.add(new Command(-1000, true, true, Function.START));
				currentRouteCommands.add(new Command(a.y, false, above, Function.STOP));
				y = a.y;
								
			}
			
			return findRouteToAddress(a);
			
		}
		
	}
	
	/**
	 * Debug method. Prints all commands currently generated by this Router.
	 */
	public void printCommandList() {
		
		System.out.println("Current route:");
		
		for(Command c : currentRouteCommands) {
			
			System.out.println(c.toString());
			
		}

		System.out.println();
		
	}
	
}
